# Natch Quickstart

*(актуально на момент бета-релиза Natch 2.0)*

## 0. Введение

Данное руководство является кратким курсом по освоению основных принципов использования системы определения ширины и глубины поверхности атаки [Natch](https://www.ispras.ru/technologies/natch/) (разработчик - [ИСП РАН](https://www.ispras.ru/)). В руководстве рассмотрены вопросы создания виртуализованных сред выполнения объекта оценки (далее - ОО) в формате [QEMU](https://wiki.qemu.org/Main_Page), запуска данных сред под контролем Natch, анализа информации о движении помеченных данных, получаемой Natch от контролируемой виртуализованной среды.

## 1. Общие вопросы

### 1.1. Общие принципы работы Natch

Natch (Network Application Tainting Can Help) - это инструмент для определения поверхности атаки, основанный на полносистемном эмуляторе Qemu. Основная функция Natch - получение списка модулей (исполняемых файлов и динамических библиотек) и функций, используемых системой во время выполнения задачи. Natch представляет собой набор плагинов для эмулятора Qemu.

Общие принципы работы Natch, доступные плагины, команды управления Natch и их параметры представлены в веб-странице руководства, доступного в комплекте поставки (открыть браузером файл `index.html` в каталоге `/docs/manual/`).

В настоящий момент Natch поддерживает анализ только бинарного кода - таким образом анализ задействования кода интерпретируемых скриптов, а также "распространения" помеченных данных по коду интерпретируемых скриптов, возможен только в опосредованном виде - в формате анализа задействования нативных функций интерпретаторов, выполняющих указанные скрипты. 

#### 1.1.1. Комплект поставки

Комплект поставки Natch доступен в двух форматах:

- **основной** - защищенный бинарный дистрибутив, требующий наличие аппаратного ключа (персональный "черный" ключ, сетевой "красный" ключ или иные версии ключа) с лицензией c идентификатором "6":

    [Natch v.2.0](https://nextcloud.ispras.ru/index.php/s/natch_v.2.0) 

- **резервный** - .ova-образ Ubuntu 20 для VirtualBox с предустановленным защищенным Natch, необходимым ПО (pip3, vim) и доступом к VPN-серверу, раздающему лицензии:

    [Natch v.2.0](https://nextcloud.ispras.ru/index.php/s/learning)

Предыдущие версии защищенного бинарного дистрибутива Natch:

[Natch v.1.3.2](https://nextcloud.ispras.ru/index.php/s/natch_v.1.3.2) 

### 1.2. Общие принципы подготовки виртуализованной среды в формате QEMU

Процесс подготовки виртуализованной среды выполнения ОО в общем случае состоит из следующих последовательных шагов:
 - создание образа эмулируемой операционной системы в формате диска [qcow2](https://en.wikipedia.org/wiki/Qcow) на основе базового дистрибутива ОС. Формат qcow2 позволяет эффективно формировать снэпшоты состояния файловой системы в произвольный момент выполнения виртулизованной среды функционирования;
 - сборка дистрибутива ОО с требуемыми параметрами, в частности с генерацией и сохранением отладочных символов;
 - помещение собранного дистрибутива ОО в виртуализованную среду выполнения; - 
 - подготовка команд запуска QEMU, обеспечивающих эмуляцию аппаратной составляющей среды функционирования, загрузку и выполнение компонент Natch. 

Процесс подготовки виртуализованной среды выполнения ОО в значительной степени совпадает с процессом подготовки виртуализованной среды для анализа с помощью инструмента динамического анализа помеченных данных [Блесна](https://www.ispras.ru/technologies/blesna/) (разработчик - [ИСП РАН](https://www.ispras.ru/)), с точностью до подготовки команд запуска QEMU.

Процесс подготовки виртуализованной среды выполнения ОО рекомендуется выполнять в хостовой системе, допускающей запуск QEMU в режиме пользовательской виртуализации (ключ `-enable-kvm`) - это существенно ускорит процесс, скорость работы в режиме аппаратной виртуализации более чем на порядок превосходит работу в режиме полносистемной эмуляции. Проверить доступность данного режима в вашей хостовой системе (равно как и установить kvm-модули в вашу систему) можно опираясь на следующую [статью](https://phoenixnap.com/kb/ubuntu-install-kvm) с помощью команды:

```bash
sudo kvm-ok
```

при написании данной статьи в моей хостовой системе такая возможность отсутствовала, но менять конфигурации хостовой ВМ VirtualBox мне не хотелось:

```bash
[sudo] password for user: 
INFO: Your CPU does not support KVM extensions
KVM acceleration can NOT be used
```

При этом важно помнить, что собственно **запись трассы в любом случае необходимо выполнять без использования данного ключа**, поскольку запись осуществляется в режиме полносистемной эмуляции, собственно и позволяющей собрать полный лог действий процессора.

### 1.3. Пример подготовки виртуализованной среды в формате QEMU

#### 1.3.1. Подготовка хостовой системы

Рекомендации по подготовке хостовой системы приведены [здесь](https://gitlab.community.ispras.ru/trackers/natch/-/wikis/Natch-requirements#%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D1%85%D0%BE%D1%81%D1%82%D0%BE%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5) (*для получения доступа к репозиторию сообщества ознакомьтесь с информацией в описании телеграм-канала [Орг. вопросы::Доверенная разработка](https://t.me/sdl_community)*).

Подготовим Linux-based рабочую станцию (далее - хост), поддерживающую графический режим выполнения (QEMU демонстрирует вывод эмулируемой среды выполнения в отдельном графическом окне, следовательно нам необходим графический режим). Рабочая станция может быть реализована в формате виртуальной машины. Данное руководство описывает действия пользователя, работающего в виртуальной машине VirtualBox (4 ядра, 8 ГБ ОЗУ) с установленной ОС [Ubuntu20:04](https://releases.ubuntu.com/20.04/ubuntu-20.04.3-desktop-amd64.iso) (desktop-конфигурация, обновить пакеты при установке). 

Установим требуемое системное ПО, в т.ч. QEMU: 

```bash
sudo apt install  -y curl qemu-system gcc g++ 
```

*Подсказка: данная инсталляция требуется не для запуска Natch, но для создания образов ВМ на произвольном хосте. Natch содержит в своём составе требуемую для работы версию QEMU, поэтому если вы планируете создавать образ ВМ на том же хосте, на котором уже установили Natch, необходимость дополнительно устанавливать QEMU отсутствует*

Рекомендации по подготовке гостевой системы приведены [здесь](https://gitlab.community.ispras.ru/trackers/natch/-/wikis/Natch-requirements#%D0%B1-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D0%B3%D0%BE%D1%81%D1%82%D0%B5%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%B5).

Скачаем на хост выбранный базовый дистрибутив ОС. Поскольку виртуальные машины QEMU в режиме полносистемной эмуляции (анализ выполняется именно в таком режиме (параметр `--enable-kvm` в строке запуска QEMU должен отсутствовать), поскольку нам требуется полная эмуляция процессора и, частично, периферии для сбора максимально полной отладочной информации) значительно замедляют выполнение анализируемой среды функционирования, рекомендуется использовать минимальный образ - уменьшение числа установленных, стартующих при запуске служб, позволит значительно сократить нагрузку на процессор и сократить время, требуемое на запись и анализ трасс в режиме полносистемной эмуляции. В данном примере для ускорения процесс в качестве базового выбран легковесный образ Ubuntu - [lubuntu](https://lubuntu.net/downloads/) - скачаем его на хост, предварительно создав на хосте какой-нибудь каталог для дальнейших экспериментов:

```bash
cd ~ && mkdir natch_quickstart && cd natch_quickstart
curl -o lubuntu-18.04-alternate-amd64.iso  'http://cdimage.ubuntu.com/lubuntu/releases/18.04/release/lubuntu-18.04-alternate-amd64.iso'
```

и выполним создание виртуальной машины (я опирался на вот это [руководство](https://graspingtech.com/ubuntu-desktop-18.04-virtual-machine-macos-qemu/), но их много разных доступно в интернете).

Проверим установку ВМ:
```bash
qemu-system-x86_64 --version
QEMU emulator version 4.2.1 (Debian 1:4.2-3ubuntu6.19)
Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers
```

Создадим образ диска в формате `qcow2`, с именем `lubuntu.qcow2` и размером `20 ГБайт`.
```bash
qemu-img create -f qcow2 lubuntu.qcow2 20G
Formatting 'lubuntu.qcow2', fmt=qcow2 size=21474836480 cluster_size=65536 lazy_refcounts=off refcount_bits=16
ll
total 8100768
drwxrwxr-x  4 user user       4096 янв 30 20:40 ./
drwxr-xr-x 25 user user       4096 янв 30 20:40 ../
-rw-rw-r--  1 user user  751828992 янв 30 20:34 lubuntu-18.04-alternate-amd64.iso
-rw-r--r--  1 user user     196928 янв 30 20:08 lubuntu.qcow2
```

Создадим скрипт запуска нашей ВМ `run.sh` - скрипт (равно как и дальнейшие скрипты в данном руководстве) достаточно объемный, поэтому желательно именно сохранять его в виде отдельного файла, допускающего удобное внесение изменений. Для тех, кто сталкивается с синтаксисом QEMU впервые, настоятельно рекомендуется ознакомиться с основными командами, подробно расписанными в официальной [документации QEMU](https://www.qemu.org/docs/master/system/invocation.html), а также в разделе руководства, посвященном QEMU.

```bash
qemu-system-x86_64 \
-hda lubuntu.qcow2  \
-m 4G \
-monitor stdio \
-netdev user,id=net0 \
-device e1000,netdev=net0 \
-cdrom lubuntu-18.04-alternate-amd64.iso
```

и выполним его:

```bash
./run.sh
```

после чего увидим знакомое нам графическое окно установки lubuntu. Выполним установку lubuntu - желательно выполнять её с минимальным набором параметров - для ускорения процесса установки и минимизации потенциального "шума" избыточных процессов и сетевых служб в записях сетевого трафика и трасс выполнения. 

*Подсказка: чтобы вывести курсор мыши из открытого графического окна ВМ QEMU нажмите Ctrl+Alt+G*

После завершения установки удалим из скрипта запуска `run.sh` указание подключения cdrom - для дальнейшей работы он нам не потребуется

```bash
#-cdrom lubuntu-18.04.3-desktop-amd64.iso
```
Наш образ среды функционирования готов к работе - в частности к установке в него пресобранного **с символами** прототипа объекта оценки.

#### 1.3.2. Сборка прототипа объекта оценки

Рекомендации по подготовке исполняемого кода приведены [здесь](https://gitlab.community.ispras.ru/trackers/natch/-/wikis/Natch-requirements#%D0%B2-%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BF%D0%BE%D0%B4%D0%BB%D0%B5%D0%B6%D0%B0%D1%89%D0%B5%D0%B9-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D1%83-%D0%B3%D0%BE%D1%81%D1%82%D0%B5%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B).

В общем случае к подлежащему анализу исполняемому коду выставляется два требования:

- для исполняемого кода должна быть представлена отладочная информация в формате символов в составе исполняемых файлов, отдельно прилагаемых символов или map-файлов. Предоставление символов непосредственно в составе исполняемых файлов является основной и рекомендуемой стратегий - начиная с версии Natch v1.3 инструмент умеет самостоятельно доставать информацию об отладочных символах из исполняемых файлов, собранных *как минимум* компиляторами gcc и clang с сохранением отладочной информации (ключ компилятора `-g`, также рекомендуется сборка без оптимизаций в режиме `-O0`). Начиная с версии Natch v2.1 будет внедрен функционал автоматической подгрузки символов для наиболее популярных сборок операционных систем;

- в случае, если процессы сборки и анализа будут выполняться в различных средах функционирования (как правило сборка осуществляется на отдельном высокопроизводительном сборочном сервере), требуется обеспечить совместимость версий разделяемых динамических библиотек, в первую очередь glibc, из состава среды функционирования.

В данном разделе в качестве прототипа объекта оценки рассмотрим популярную программу wget, сборку которой осуществим в хостовой системе (условная "сборочница") с последующим помещением собранного дистрибутива в виртуализированную гостевую среду lubuntu. 

Для выполнения [*классического*](https://thoughtbot.com/blog/the-magic-behind-configure-make-make-install) подготовительного скрипта `configure`, входящего в комплект поставки wget, генерирующего make-файл, потребуется установить ряд дополнительных зависимостей (скрипт выведет их наименования в случае неудачного завершения), в том числе для моей системы потребовалось:

```bash
sudo apt install -y gnutls-dev gnutls-bin curl
```

*Подсказка: поскольку я собираюсь собирать wget из исходников мне нужен комплект заголовочных файлов, доступный как раз в dev-версии пакета gnutls*

Скачаем исходные тексты wget с репозитория в файловую систему хоста (как и обозначено выше, сборку будем проводить именно на хосте):
```bash
curl -o wget-1.21.2.tar.gz  'https://ftp.gnu.org/gnu/wget/wget-1.21.2.tar.gz'
tar -xzf wget-1.21.2.tar.gz && cd wget-1.21.2
```

Успешное выполнение скрипта `configure` с определенными предустановками (ключи компилятора `-g -O0` ) позволит в т.ч. установить параметры компилятора, обеспечивающие сохранение информации об отладочных символах. 


**Важное замечание - следующие два подраздела оставлены в качестве пособия для специфических случаев, когда возможность сборки исполняемого файла из исходных текстов с произвольными параметрами отсутствует, либо явно требуется получение отдельных [map-файлов](https://stackoverflow.com/questions/22199844/what-are-gcc-linker-map-files-used-for).**

#### 1.3.3. *Генерация map-файлов средствами компилятора*

Выполним скрипт: 

```bash
CFLAGS='-g -O0 -Xlinker -Map=output.map' ./configure && \
make
```

и проверим, что map-файлы создались. 

```bash
find . -name *.map
./src/output.map
./output.map
```

Полученные map-файлы можно поместить на хосте в явно обозначенный Natch`у каталог, содержащий исполняемые файлы wget - тогда Natch будет опираться на данные map-файлы при символизации соответствующиех процессов.

#### 1.3.4. *Генерация map-файлов сторонними инструментами*

Получение map-файлов для исполняемого файла, собранного с отладочными символами, возможно с помощью сторонних инструментов. Это может быть актуально в тех случаях, когда сборочный конвейер недоступен, либо получение от сборочного конвейера map-файлов в поддерживаемом Natch формате невозможно (например, использование специфического компилятора/компоновщика). Сгенерируем map-файлы с использованием бесплатной версии дизассемблера [IDA](https://hex-rays.com/ida-free/) - необходимо скачать установочный комплект по указанной ссылке, возможно в систему придётся доустановить библиотеки Qt `apt install -y qt5-default`.

После установки IDA необходимо запустить её, открыть интересующий нас исполняемый файл (в нашем случае это `wget`)

![image](https://user-images.githubusercontent.com/46653985/152351389-7cd54129-c087-4dc3-8bf6-be500f8193c3.png)

пройти процедуру генерации map-файла

![image](https://user-images.githubusercontent.com/46653985/152351322-d92d16e0-5650-4c96-a61a-3abeb992b18e.png)


выбрав экспорт всей возможной информации

<img src="https://user-images.githubusercontent.com/46653985/152351245-d3a3510f-adba-4919-adfb-be081a6800e8.png" width="200" height="200">

после чего убедиться, что map-файл появился в файловой системе

```bash
ll src | grep .map
-rw-rw-r--  1 user user  564686 фев  3 16:11 wget.map
```

#### 1.3.5. Перенос прототипа объекта оценки в образ ВМ

Существуют различные способы помещения обмена информацией между хостом и виртуальной машиной. Воспользуемся подходом, основанным на использовании [nbd-сервера QEMU](https://manpages.debian.org/testing/qemu-utils/qemu-nbd.8.en.html), позволяющим [смонтировать](https://gist.github.com/shamil/62935d9b456a6f9877b5) созданный ранее qcow2-диск ВМ в файловую систему хостовой ОС. Для выполнения монтирования диск не должен быть задействован (виртуальная машина должна быть выключена).

Загрузим NBD-драйвер в ядро хостовой ОС:

```bash
modprobe nbd max_part=8
```

Смонтируем наш образ диска как сетевое блочное устройство:
```bash
sudo qemu-nbd --connect=/dev/nbd0 lubuntu.qcow2
```

Определим число разделов на устройстве:
```bash
fdisk /dev/nbd0 -l
Disk /dev/nbd0: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xe6ea1316

Device      Boot Start      End  Sectors Size Id Type
/dev/nbd0p1 *     2048 41940991 41938944  20G 83 Linux

```

Смонтируем раздел в какой-либо каталог хостовой ОС (например, традиционно, в mnt)
```bash
sudo mount /dev/nbd0p1 /mnt/
ls /mnt
bin   dev  home        initrd.img.old  lib64       media  opt   root  sbin  swapfile  tmp  var      vmlinuz.old
boot  etc  initrd.img  lib             lost+found  mnt    proc  run   srv   sys       usr  vmlinuz
```

Поместим прототип ОО на смонтированный раздел:
```bash
sudo cp -r wget-1.21.2 /mnt/ && ls /mnt
bin   dev  home        initrd.img.old  lib64       media  opt   root  sbin  swapfile  tmp  var      vmlinuz.old
boot  etc  initrd.img  lib             lost+found  mnt    proc  run   srv   sys       usr  vmlinuz  wget-1.21.2
```

Отмонтируем диск:
```bash
sudo umount /mnt/
sudo qemu-nbd --disconnect /dev/nbd0
sudo rmmod nbd
```

#### 1.3.6. Тестирование виртуализированной среды функционирования ОО

Запускаем ВМ скриптом `run.sh` с учетом отключенного ранее cdrom, дожидаемся загрузки ОС ВМ, авторизуемся в ОС от имени учетной записи test, пробуем выполнить обращение к произвольному сетевому ресурсу с помощью собранной нами версии wget:

```bash
cd /wget-1.21.2 && sudo ./wget ispras.ru
```

В результате вы должны увидеть приблизительно следующую картину в графическом окне QEMU, свидетельствующую о том, что ОО корректно выполняется в среде функционирования и сетевая доступность для ВМ обеспечена:

![image](https://user-images.githubusercontent.com/46653985/151779302-c2d59bd1-aed1-45ce-8f00-2702380a3157.png)


## 2. Обучающие примеры 

### 2.1. Анализ образа системы, содержащего пресобранную с символами программу wget2

Для выполнения данного примера потребуется:
- рабочая станция под управлением ОС Linux (традиционно Ubuntu 20.04). Отдельная установка пакета **qemu-system** не требуется, нужная версия входит в дистрибутив Natch;
- актуальный [дистрибутив](#111-комплект-поставки) Natch;
- подготовленный разработчиком [тестовый набор](https://nextcloud.ispras.ru/index.php/s/testing_2.0), включающий в себя минимизированный образ гостевой операционной системы Debian (размер qcow2-образа около 1 ГБ), а также два комплекта бинарных файлов (Sample1_bins и Sample2_bins), собранных с символами, к которым дополнительно прилагаются map-файлы. 

*Сценарий использования комплекта Sample1_bins*

Исполняемый файл test_sample читает помеченный файл (таковым при конфигурировании Natch нужно установить файл sample.txt в гостевой ОС), в первой строке которого записан адрес Google, выдергивает эту первую (уже помеченную в процессе чтения файла) строчку и вызывает исполняемый файл test_sample_2 - в качестве параметра используется эта строка. test_sample_2 "курлит гугл" в файл curl.txt. 

*Сценарий использования комплекта Sample2_bins*

Процесс сервера redis-server следует запустить командой `redis-server --port 5555 --protected-mode no` (разумеется при конфигурировании Natch следует настроить проброс порта 5555, чтобы он был доступен из хостовой системы), после чего соединиться с ним из хостовой системы клиентской утилитой `redis-cli -h localhost -p 15555` (её можно поставить используя например так `sudo apt install redis-tools`) и выполнить какие-нибудь действия - например `SET b VeryBigValue`. 


#### 2.1.1. Получение образа и дистрибутива

В случае выполнении действий в подготовленной виртуальной машине, содержащей Natch, самостоятельные скачивание и установка бинарного комплекта не требуются.

В случае установки в формате бинарного комплекта следует скачать его и распаковать.  

Получение тестовых материалов Natch (подготовленный образ Linux с пресобранной программой wget2, подлежащей анализу):

```bash
# Получение тестовых материалов Natch
curl -o Natch_testing_materials.zip 'https://nextcloud.ispras.ru/index.php/s/testing_materials/download?path=%2F&downloadStartSecret=mv78e6aiu1' && \
unzip Natch_testing_materials.zip && \
mv Natch_testing_materials/* . && \
unzip -u wget.zip && \
rm -rf Natch_testing_materials && \
rm Natch_testing_materials.zip && \
rm wget.zip
```

Проверим, что всё на месте - реальное размещение файлов тестовых материалов непринципиально (в данном случае я поместил их непосредственно в каталог рабочих файлов Natch):
```bash
ls -la
total 7150948
drwxrwxr-x  6 tester tester       4096 мая 21 12:14 .
drwxr-xr-x 19 tester tester       4096 мая 10 10:30 ..
-rw-r--r--  1 tester tester     197632 апр 19 23:08 debian10_wget2.diff
-rw-r--r--  1 tester tester 7322337280 апр 21 09:52 debian10_wget2.qcow2
drwxrwxr-x  3 tester tester       4096 апр 22 10:52 docs
drwxr-xr-x  2 tester tester       4096 апр 21 16:25 libs
drwxr-xr-x  9 tester tester       4096 апр 21 16:25 qemu_plugins_2004_natch_release
drwxrwxr-x  3 tester tester       4096 дек 23 15:17 wget2
-rw-rw-r--  1 tester tester        208 апр 19 23:00 wget_api.cfg
```

В каталоге `docs` размещается веб-страница руководства. В каталоге `libs` размещаются используемые Natch библиотеки (подключаются с использованием стандартного механизма [preload](https://www.baeldung.com/linux/ld_preload-trick-what-is#:~:text=The%20LD_PRELOAD%20trick%20is%20a,a%20collection%20of%20compiled%20functions.) при запуске qemu-system). В каталоге `qemu_plugins...` помещаются собственно исполняемые файлы Natch. Подготовленный образ в формате qcow2, каталог с пресобранной версией wget2 а также файл конфигурации `wget_api.cfg` (будет рассмотрен ниже) помещены в корень рабочего каталога (размещение не принципиально).

#### 2.1.2. Установка python-библиотек, обеспечивающих работоспособность скриптов
```bash
cd qemu_plugins_2004_natch_release/bin/natch_scripts/
pip3 install -r requirements.txt
```

#### 2.1.3. Настройка Natch

Процесс настройки Natch состоит из четырёх этапов (предназначение файлов конфигурации и их параметров **подробно расписано в документации**):

##### 2.1.3.Этап 1. Заполнение конфигурации маппинга исполняемых модулей

Заполнение данного файла позволяет повысить вероятность распознавания Natch имен модулей и функций, исполняемых в виртуализированной среде. В комплекте поставки тестового примера имеется предзаполненный файл `wget_api.cfg`, который содержит маппинги для пресобранных с символами исполняемого файла wget2 и разделяемой библиотеки libwget.so.1.0.0, расположенных в каталоге `natch_quickstart\wget2` хостовой системы в формате непосредственно указания пути к файлу и соответствующего ему map-файла (альтернативный подход - указание пути к каталогу со всеми образами исполняемых файлов - описан в документации). Первоначально файл имеет следующий вид:

```bash
cat wget_api.cfg 
[Image1]
path=wget2/wget2
map=wget2/wget2.map
textstart=0xC000

[Image2]
path=wget2/lib/libwget.so.1.0.0
map=wget2/lib/libwget.so.1.0.0.map
textstart=0xe000
```

Модифицируем файл, указав абсолютные пути (для надёжности) и удалив описание секции `textstart` (избыточно, поскольку адреса функции нашего исполняемого файла заданы в относительном формате, что допускает их автоматическое вычисление без дополнительной информации - см. документацию п. 2.2): 

```bash
cat ../wget_api.cfg 
[Image1]
path=/home/tester/natch_quickstart/wget2/wget2
map=/home/tester/natch_quickstart/wget2/wget2.map

[Image2]
path=/home/tester/natch_quickstart/wget2/lib/libwget.so.1.0.0
map=/home/tester/natch_quickstart/wget2/lib/libwget.so.1.0.0.map
```

Начиная с версии Natch v1.3 заполнение конфигурационного файла можно и нужно автоматизировать, указав на вход скрипту `qemu_plugins_2004_natch_release/bin/natch_scripts\module_config.py`, описанному в п. 2.2 документации, имя каталога на хосте, содержащего исполняемые файлы и map-файлы (имена map-файлов должны совпадать с именами соответствующих исполняемых файлов). Данный скрипт заполнит пути, также заполнит секцию textstart если определит, что таковое заполнение необходимо:

```bash
$ ./module_config.py /home/tester/natch_quickstart/wget2

$ cat module_config.cfg 
[Image1]
path=/home/tester/natch_quickstart/wget2/wget2
map=/home/tester/natch_quickstart/wget2/wget2.map

[Image2]
path=/home/tester/natch_quickstart/wget2/lib/libwget.so.1.0.0
map=/home/tester/natch_quickstart/wget2/lib/libwget.so.1.0.0.map
```

##### 2.1.3.Этап 2. Формирование скриптового и конфигурационного окружения

С целью решения задачи автоматизации порождения типовых скриптов управления и основного файла конфигурации Natch создан скрипт `natch_run.py`. На вход данному скрипту необходимо подать некоторые параметры, такие как:
- имя образа qcow2 (обязательный параметр)
- ряд опциональных параметров (выделяемый ВМ объем RAM, специальная версия ядра Линукс), в т.ч. включающих/выключающих некоторые аналитические возможности Natch (подробнее см. документацию п. 3.1) 

Параметр пути к образу qcow2 допускается задавать в виде переменной скрипта, воспользуемся этим подходом:

```bash
cd qemu_plugins_2004_natch_release/bin/natch_scripts && \
./natch_run.py  ~/natch_quickstart/debian10_wget2.qcow2
```

И несколько нажатий Enter - параметры по умолчанию нас устраивают, за исключение принудительно включаемых генераторов графов:

```bash
Image: /home/tester/natch_quickstart/debian10_wget2.qcow2
Common options
Enter RAM size (in Gb, e.g. 4): 
The default value is set to 4Gb
Do you want include launch Natch into command line? [Y/n] 
Natch options
Enter name of config file or press Enter for using default name: 
Do you want enable task_graph? [y/N]  y        <<-- Включить отрисовку графа задач
Do you want enable module_graph? [y/N]  y        <<-- Включить отрисовку графа модулей
Only for record mode
Do you want enable net_log? [Y/n]  
Now we will try to create overlay
Overlay created        <<-- Успешно создан слой для виртуального диска
Enter custom options (with '-'): 

Settings completed!

Here is your command line one:
```

Мы должны увидеть лог, содержащий сообщения о том, что скрипты запуска Natch подготовлены успешно:

```bash
...
File '/home/tester/natch_quickstart/qemu_plugins_2004_natch_release/bin/natch_scripts/natch_config.cfg' created. You must edit it before using Natch.

After checking config file you can launch:
	just Qemu with help './run.sh'
	Qemu in record mode with help'./run_record.sh'
	Qemu in replay mode with help'./run_replay.sh'

```
а также три скрипта: 
- скрипт первого - настроечного - запуска Natch (подробнее см. документацию п. 3.3)
- скрипт запуск Natch в режиме записи трассы для последующего анализа (подробнее см. документацию п. 3.4)
- скрипт запуска Natch в режиме воспроизведения и анализа трассы (подробнее см. документацию п. 3.5) 

Отредактируем сгенерированный основной конфигурационный файл  Natch `natch_config.cfg` в соответствии с рекомендациями (подробнее см. документацию п. 2.1). В качестве порта - источника помеченных данных - оставим порты 80 и 443 (в ходе теста будем выполнять обращение к сайту по HTTP-протоколу (80), после чего будет выполнено автоматическое перенаправление на HTTPS-версию страницы (443)). Раскомментируем секцию Taint для сохранения сведений о взаимодействии анализируемого процесса с помеченными данными. Укажем путь к файлам, содержащим map-файлы, в секции Modules. В секции Coverage установим taint в значение true - благодаря этому Natch будет собирать покрытие только для тех базовых блоков, которые взаимодействуют с помеченными данными, и игнорировать функции, не связанные с обработкой помеченных данных (_Не забываем, что необходимо раскомментировать также названия секций в квадратных скобках, а не только сами параметры._)

```bash
# Natch config sample

[Ports]
in=80;443
out=80;443

[Taint]
threshold=250
on=true

[Modules]
config=/home/tester/natch_quickstart/wget_api.cfg
log=api_taint_log.txt
params_log=params_log.txt

[Tasks]
config=task_config.ini
file=processes.log

# [Syscalls]
# config=x86_64_Linux.cfg

[NetLog]
log=netpackets.log
tlog=tnetpackets.log

# [Icount]
# steps=1111111111;5555555555

# [TaintFile]
# list=file1.txt;file2.txt

[Coverage]
file=coverage.cov64
taint=true

#[Plugins]	
# items=bcqti,broker,addr=:5555;some_plugin
```

Выполним настроечный запуск Natch с помощью сформированного скрипта `run.sh`, не забыв указать путь к ряду библиотек с помощью уже упоминавшегося механизма LD_PRELOAD:

```bash
LD_LIBRARY_PATH=~/natch_quickstart/libs/ ./run.sh
```
Появится окно монитора qemu, отображающее загрузку гостевой ОС, а в консоль хостового терминала будет выведен текст наподобие:

![image](https://user-images.githubusercontent.com/46653985/169648848-11e8239e-9673-452b-8eaf-582be8b30de4.png)

Через 1-2 минуты процесс завершится успешно (_нюанс - в моем случае при запуске qemu внутри виртуальной машины VBox периодически отмечается подвисание GUI хостовой ОС. Лечится в частности минимизацией/максимизацией окна виртуальной машины VBox_):

![image](https://user-images.githubusercontent.com/46653985/164392153-7608f8d8-e5dc-44a6-accf-767bd1b43e2e.png)

##### 2.1.3.Этап 3. Проброс портов гостевой ОС в хостовую ОС

Для случаев, когда нам потребуется взаимодействовать с сетевыми сервисами виртуальной машиной извне, необходимо добавить в скрипты запуска qemu команды, обеспечивающие проброс портов. Пример таковой строки, расширяющей команду `-netdev`, делающей доступным из внешнего хоста (при обращении по адресу 127.0.0.1:10080) сервиса во внутреннем хосте, доступного на внутреннем адресе 127.0.0.1:80, приведён ниже (команда host=10.0.2.10 "назначает" этот IP-адрес внешнему хосту, чтобы под таким адресом он был доступен из внутреннего хоста):

`-netdev user,id=net0,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10080-:80`

В настоящий момент рекомендуется выполнять все сетевые взаимодействия с тестируемыми сервисами именно извне виртуальной машины - **корректная пометка обращений по localhost, UNIX-сокетам внутри виртуальной машины не гарантируется**.

Теперь всё готово к записи трассы.

##### 2.1.3.Этап 4. Запись трассы

Выполним запись трассы с интересующим нас сценарием выполнения. 
```bash
LD_LIBRARY_PATH=~/natch_quickstart/libs/ ./run_record.sh
```

Введём логин и пароль - nat:123:

![image](https://user-images.githubusercontent.com/46653985/169649610-66112f49-ba02-4422-b11f-3ec8b6efe1c9.png)

Перейдем в каталог wget2/src, где собственно и лежит **пресобранная версия wget2** (не перепутайте с базовым wget2, присутствующим в гостевой операционной системе), и подготовим в консоли строку запуска wget2 (у вас она может быть иной, лишь бы была корректной и обращалась к внешнему ресурсу). 

![image](https://user-images.githubusercontent.com/46653985/169653153-8476fa22-232e-4f13-99af-2dafac3aee4f.png)

Важный момент - трасса длинная, включает в себя в том числе этап загрузки ОС - но помеченные данные появятся в практически в самом конце, когда мы обратимся к внешнему сетевому ресурсу с помощью wget2. Соответственно для существенного сокращения времени на анализ (последующее выполнение ./run_replay) нам потребуется сделать снэпшот в точке, максимально приближенной к точке начала поступления помеченных данных в системе. То есть сейчас, когда от порождения помеченных данных нас отделяет только нажатие Enter.

Нажмем `Ctrl (в моём случае левый) + Alt + G`, выйдем в монитор qemu и выполним команду генерации снэпшота (займёт около 1 минуты) - я назвал его `ready_to_go` - **команда savevm ready_to_go, её плохо видно на скрине**:

![image](https://user-images.githubusercontent.com/46653985/169649738-0def47f6-b1b8-4544-9f72-7dc74a25be9d.png)

После того, как снэпшот был сгенерирован, вернёмся в гостевую ОС и выполним вызов wget2 и контрольное ознакомление с результатами (достаточно убедиться, что мы достучались до сайта и он что-то вернул), после чего закроем графическое окно и завершим выполнение qemu:

```bash
wget -O /tmp/index.html -o /tmp/log www.warandpeace.ru \
cat /tmp/index.html | head -n 15
```

После этого модифицируем скрипт `run_replay.sh` заменим стандартное имя снэпшота `init` на `ready_to_go`.

![image](https://user-images.githubusercontent.com/46653985/169650073-78d3918f-7044-412a-8474-f5f763438d8f.png)

Теперь всё готово к анализу трассы.

##### 2.1.3.Этап 5. Воспроизведение трассы

```bash
LD_LIBRARY_PATH=~/natch_quickstart/libs/ ./run_replay.sh
```

Начнём воспроизведение трассы (приблизительно на порядок медленнее, чем базовой выполнение - вы моментально оцените пользу создания снэпшота):

![image](https://user-images.githubusercontent.com/46653985/169650206-15ab58e0-bcb0-4eb5-aa38-2c7b4777216c.png)

В ходе выполнения, в случае если вам требуются какие-то диагностики, имеющие отношение к конкретному моменту, в мониторе можно вводить различные команды, в частности команды плагинов Natch, указанные в п. 5 документации, например команду `show_tasks`, возвращающую дерево процессов в гостевой ОС, на момент её выполнения:

![image](https://user-images.githubusercontent.com/46653985/169652276-5fc5e8e5-6d91-4e84-b53e-333074d39f9c.png)

Через какое-то время выполнение сценария завершится, графическое окно закроется, и вы должны будете увидеть сообщение наподобие приведённого на рисунке ниже, свидетельствующее о том, что интересующие нас модули гостевой ОС были распознаны успешно, и следовательно мы получим в отчетах корректно символизированную информацию.

![image](https://user-images.githubusercontent.com/46653985/169653222-8d8ad214-ccf1-42f3-b938-aaa04568eaa3.png)

##### 2.1.3.Этап 6. Анализ трассы

Основные виды диагностики, предоставляемые Natch, расписаны в п. 4 руководства. Следует ознакомиться со списками:
- задействованных модулей
- задействованных функций
- функций, вызывавших задействованные функции

а также:
- графом движения помеченных данных
- сетевым трафиком, доступным в pcap-файле `on.pcap`, а также в файле лога помеченных данных `tnetpackets.log` 

а также проанализировать:
- какие функции в наибольшей степени взаимодействовали с помеченными данными
- покрытие по базовым блокам функций, взаимодействовавших с помеченными данными

Анализ покрытия по базовым блокам выполняется с использованием IDA Pro (протестировано на версиях 7.0, 7.2), общий алгоритм действий описан в п. 4.7.2 документации. В ходе его выполнения может потребоваться ручное сопоставление модуля, для которого собрано покрытие, с модулем, загруженным в IDA. Наиболее явная причина - несовпадение имён исполняемого файла и файла, распознанного Natch. Пример такового несовпадения приведён на рисунке ниже:

![image](https://user-images.githubusercontent.com/46653985/169868133-325ba022-0cef-4d12-be6a-0390d3f22178.png)

После выполнения маппинга в представленном выше меню в ручном режиме мы увидим приблизительно следующие сведения о покрытии:

![image](https://user-images.githubusercontent.com/46653985/169868949-e46d60e6-a2b5-47a5-8801-e6857953a7b6.png)

Также при выборе функции можно увидеть покрытие непосредственно по ассемблерным инструкциям (голубой цвет):

![image](https://user-images.githubusercontent.com/46653985/169868764-24e49753-294a-4722-a71f-633e1f233063.png)

Демонстрация покрытия по декомпилированному коду в настоящий момент не поддерживается.






